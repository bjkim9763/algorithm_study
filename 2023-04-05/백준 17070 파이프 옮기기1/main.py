'''
1. 해결법

1) 가로, 세로 대각선 파이프를 언제 놓을 수 있을까
-가로 => 이전에 설치한 파이프가 대각선 or 가로
-세로 => 이전에 설치한 파이프가 대각선 or 세로
-대각선 => 이전에 설치한 파이프 상관 x

2) 벽
벽이 주위에 있으면 파이프를 놓을 수 없다.
이 때 가로 혹은 세로는 벽으로 진로가 막혀있으면 당연히 놓을 수 없으므로 대각선만 주의
-대각선 => 나아가려는 진로와 그 위쪽, 왼쪽에 벽이 없어야 한다.

3) 알고리즘
dp를 이용해 나아가는 진로를 기록하며 해결한다.
진로를 기록하기 위해 각 가로, 세로, 대각선 파이프의 끝부분이 놓여지는 위치를 1로 둔다.
이 때 첫 가로줄에는 가로 파이프밖에 올 수 없고, 세로 줄에는 어떠한 파이프도 올 수 없으니, 이는 처음부터 만들고 간다.

'''
import sys

input = sys.stdin.readline

n = int(input())
house = [[0 for _ in range(n+1)]]
dp = [[[0 for _ in range(n+1)] for _ in range(n+1)]for _ in range(4)] # 가로=1 세로=2 대각선=3 의 배열안에 각 2차원 배열위치 ex) dp[1][2][3] => house[2][3]의 가로 파이프
for i in range(n):
    arr = [0] + list(map(int, input().split()))
    house.append(arr)
dp[1][1][2] = 1 # 처음 시작할 때 파이프는 가로이고 그 끝부분은 (1,2)
for i in range(3, n+1): # 1행은 가로파이프만 올 수 있음. 벽을 만나면 그 이후는 0
    if house[1][i] == 0: # 위에서 따로 초기화한 첫번째 상태 이후, 1이면 벽이므로 그 이후는 계산 x
        dp[1][1][i] = dp[1][1][i-1] # 1행에선 가로 파이프만 가능, 만약 (1,2)에 가로파이프가 있다면 (1,3)도 벽이 없는 이상 가로파이프가 놓여질 수 있음
        # 참고로 1열은 계산 제외 어떤 파이프도 1열로 갈 수가 없음

for i in range(2,n + 1):  # 1행은 위해서 해결 1열은 파이프 놓기 불가 즉 (2,2)부터 연산
    for j in range(2,n + 1):
        # dp에 입렵하는 수는 방법의 개수이다. 예를 들어 dp[3][1][2] 라고 하면 (1,2)로 갈 수 있는 방법의 개수
        # 대각선 파이프 추가
        if house[i][j] == 0 and house[i-1][j] == 0 and house[i][j-1] == 0:
            dp[3][i][j] = dp[1][i-1][j-1] + dp[2][i-1][j-1] + dp[3][i-1][j-1]  # 대각선 파이프는 이전 블록이 가로, 세로, 대각선 일때 놓을 수 있으므로 이전 블록의 가로, 세로 대각선 경우의 수를 전부 더한다.
        # 가로, 세로 파이프 추가
        # 두 파이프 모두 진로 방향에만 벽이 없으면 됨
        if house[i][j] == 0:
            dp[1][i][j] = dp[1][i][j-1] + dp[3][i][j-1]  # 가로 파이프는 이전 블록이 가로, 대각선일때 놓을 수 있음
            dp[2][i][j] = dp[2][i-1][j] + dp[3][i-1][j]  # 세로 파이프는 이전 블록이 세로, 대각선일때 놓을 수 있음
result = dp[1][n][n] + dp[2][n][n] + dp[3][n][n]  # (n,n)의 가로 세로 대각선 경우의 수 총 합 구하기
print(result)