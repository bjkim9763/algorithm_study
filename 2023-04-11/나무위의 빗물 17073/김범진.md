# 문제

트리란, 사이클이 없는 연결 그래프를 의미한다. 위 그림은 1번 정점을 루트로 하는 어떤 트리를 나타낸 모습이다.

사실 이 트리는 영훈이가 뒷마당에서 기르고 있는 나무이다. 어제는 비가 왔기 때문에, 트리의 1번 정점에는 W만큼의 물이 고여 있다. 1번 정점을 제외한 모든 정점에는 아직 물이 고여 있지 않은 상태이다.

이제 매초마다 모든 정점은 아래의 작업을 순서대로 반복한다.

물을 가지고 있으며, 자식 정점이 있다면 자식 정점 중 하나를 골라 물을 1 준다. 자식 정점이 여러 개라면 동일한 확률로 그 중 하나를 고른다.
만약 부모 정점이 자신에게 물을 흘려보냈다면 받아서 쌓아 둔다.
이때, 위 작업은 순서대로 진행되므로 부모 정점에게 받은 물을 즉시 자식 정점에게 줄 수는 없다.

영훈이는 나무를 바라보면서 더 이상 물이 움직이지 않는 상태가 되었을 때 각 정점에 어느 정도의 물이 있게 될지 궁금해졌다. 더 이상 물이 움직이지 않을 때, i번 정점에 쌓인 물의 양의 기댓값을 Pi라 하자. 이때, Pi가 0보다 큰 정점들에 대해서 Pi들의 평균은 어느 정도가 될까?

# 입력
첫째 줄에 트리의 노드의 수 N과 1번 노드에 고인 물의 양을 의미하는 정수 W가 주어진다. (2 ≤ N ≤ 500,000, 1 ≤ W ≤ 109)

다음 N-1줄에 걸쳐, 트리에 존재하는 간선의 정보가 U V의 형태로 주어진다. (1 ≤ U, V ≤ N​​​​, U ≠ V)

이는 양 끝 정점이 각각 U와 V인 간선이 트리에 존재한다는 의미이다.

입력으로 주어지는 트리는 항상 올바른 연결 트리임이 보장되며, 주어지는 트리의 루트는 항상 1번 정점이다.

# 출력
문제의 정답을 출력한다. 정답과의 차이가 10-3 이하인 값은 모두 정답으로 인정된다.

# 접근 방법

문제가 복잡하게 쓰여있어서 헷갈렸지만, 결국에 마지막 장면에서 물이 존재하는 노드들의 평균값을 구하라는 것이다.
트리의 특징상 물은 계속해서 아래로 고일 것이고, 결국엔 리프노드에 다다를 것이다. 이 문제를 단순화하면 결국 리프노드의 개수로 물의 무게를 나누라는 것이다.
이를 위해 list를 이용했다. edge를 입력받아 이를 바탕으로 tree를 구성했고, 이 tree에서 연결되어 있는 노드의 개수가 1개인 노드는 부모만 존재하고 자식노드가 없는 리프노드라는 뜻이므로 이들을 세어주었다.

# 헤멘 지점
첫 번째 노드는 부모가 없고 자식만 있다. 그러므로 길이가 1일 가능성이 있다는 것을 생각 못해 오류가 발생했다. 따라서 tree의 첫 번째 정점은 빼고 세어주기로 했다.

```python
'''
1. 문제
트리의 시작점에서 아래로 계속해서 물이 흐른다.
물은 계속해서 자식 노드를 향해 흐르고 리프노드에 다다라서야 멈춘다.
i번 정점에 쌓인 물의 양의 기댓값이 0보다 크다는 것은 물이 있다는 것이고 리프노드를 의미한다.
즉 이 문제에서 전체 물의 양 / 리프노드 합 의 값을 구하면 되는 것이다.
'''

import sys

input = sys.stdin.readline

n, w = map(int, input().split())
leaf_sum = 0
edge = [list(map(int, input().split())) for _ in range(n-1)]
tree = [[] for _ in range(n+1)]
for i in edge:
    tree[i[0]].append(i[1])
    tree[i[1]].append(i[0])
for i in range(2, len(tree)): # 첫 번째 노드 즉 정점은 부모가 없으므로 길이가 1일 수 있으므로 제외하고 세어준다.
    if len(tree[i]) == 1:
        leaf_sum += 1
result = w / leaf_sum

print(result)
````